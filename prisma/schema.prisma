generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum UserRole {
  PATIENT
  DOCTOR
  ADMIN
}

enum UserStatus {
  INIT                      // Just created with role
  PENDING_EMAIL_VERIFICATION // Basic info added, waiting for email verification
  EMAIL_VERIFIED            // Email verified, profile incomplete
  PENDING_ADMIN_APPROVAL    // Admin approval pending
  ACTIVE                    // Profile completed, can login
  INACTIVE                  // Admin deactivated
  SUSPENDED                 // Admin suspended
}

enum TokenType {
  ACCESS
  REFRESH
}


enum NotificationType {
  CONNECTION_REQUEST
  CONNECTION_ACCEPTED
  NEW_CONNECTION
  QR_SCANNED
  NEW_MESSAGE
  NEW_CHAT_MESSAGE 
}


enum ConnectionStatus {
  ACTIVE
  INACTIVE
  BLOCKED
}

enum RequestStatus {
  PENDING
  ACCEPTED
  REJECTED
}

enum DocumentType {
  LAB_RESULT
  XRAY
  PRESCRIPTION
  MEDICAL_REPORT
  OTHER
}

enum ConnectionType {
  SCANNED      // من العيادة (instant) - EXISTING
  REQUESTED    // Patient request - EXISTING
  QR_CODE      // via QR scan - NEW ✅
  ADMIN_ADDED  // Added by admin - EXISTING (if exists)
}

model User {
  id              String     @id @default(uuid())
  email           String     @unique
  password        String
  firstName       String
  lastName        String
  phone           String?
  role            UserRole   @default(PATIENT)

  // Status & Approval
  status          UserStatus 
  isActive        Boolean    @default(false)
  approvedAt      DateTime?
  approvedBy      String?
  rejectionReason String?
  isProfileComplete Boolean @default(false)
  registrationStep Int      @default(0) // 0=init, 1=basic, 2=verified, 3=complete

  // Identity Docs (Doctors only)
  nationalId      String?    @unique
  idCardImage     String?

  // Timestamps
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  // Relations
  patient             Patient?
  doctor              Doctor?
  otps                Otp[]
  tokens              AuthToken[]
  notifications       Notification[]
  sendMessages        Massage[]


  @@index([status])
  @@index([isActive])
  @@map("users")
}

model Otp {
  id        String   @id @default(uuid())
  userId    String
  code      String
  type      String // 'EMAIL_VERIFICATION', 'LOGIN_VERIFICATION', 'PASSWORD_RESET'
  expiresAt DateTime
  isUsed    Boolean  @default(false)
  createdAt DateTime @default(now())

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("otps")
}

model AuthToken {
  id         String    @id @default(uuid())
  userId     String
  token      String    @unique
  type       TokenType
  isRevoked  Boolean   @default(false)
  createdAt  DateTime  @default(now())
  expiresAt  DateTime

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("auth_tokens")
}

model Notification {
  id         String           @id @default(uuid())
  userId     String
  message    String
  type       NotificationType @default(CONNECTION_REQUEST)
  title     String
  metadata  Json?
  isRead     Boolean          @default(false)
  createdAt  DateTime         @default(now())
  updatedAt DateTime @updatedAt


  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

   @@index([createdAt])
   @@index([userId, isRead])
  @@map("notifications")
}

model Patient {
  id               String    @id @default(uuid())
  userId           String    @unique
   // Personal Info
   profilePhoto   String?
  dateOfBirth      DateTime?
  gender           String?
  bloodType        String?
  height         Float?
  weight         Float?

// Contact & Address
  phone           String?
  address          String?
  city           String?
  governorate    String?

   // Medical Info
  allergies      String?
  chronicDiseases String?
  currentMedications String?
  emergencyContact String?
  emergencyPhone String?

  // Relations
  user           User            @relation(fields: [userId], references: [id], onDelete: Cascade)
  medicalRecords MedicalRecord[]

  connections         DoctorPatientConnection[]
  followUpRequests    FollowUpRequest[]
  prescriptions       Prescription[]
  qrTokens           QrToken[]  // ✅ NEW - QR codes used by patient


  @@index([userId])

  @@map("patients")
}

model Specialization {
  id          String  @id @default(uuid())
  name        String  @unique
  nameAr      String?
  description String?

  // Relations
  doctors Doctor[]

  @@map("specializations")
}

model Doctor {
  id               String   @id @default(uuid())
  userId           String   @unique
  specializationId String?
  licenseNumber    String?  @unique
  experience       Int?
  bio              String?
  consultationFee  Decimal?

  // Working hours
  workingDays  Json?
  workingHours Json?

  // Relations
  user           User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  specialization Specialization? @relation(fields: [specializationId], references: [id])
  qrTokens                QrToken[]  
  connections         DoctorPatientConnection[]
  followUpRequests    FollowUpRequest[]
  prescriptions       Prescription[]
  medicalRecords      MedicalRecord[]

  @@map("doctors")
}

model DoctorPatientConnection {
  id              String            @id @default(uuid())
  doctorId        String
  patientId       String
  connectionType  ConnectionType?
  status          ConnectionStatus  @default(ACTIVE)
  
  // Communication schedule (set by doctor after accepting)
  availableDays   Json?             // ["wednesday", "friday"]
  availableHours  Json?             // {"start": "17:00", "end": "21:00"}
  
  connectedAt     DateTime          @default(now())
  lastActivityAt  DateTime?

  lastMassageAt   DateTime?
  unreadCount     Int?
  
  // Relations
  prescriptions   Prescription[]
  medicalRecords  MedicalRecord[]
  doctor          Doctor            @relation(fields: [doctorId], references: [id])
  patient         Patient           @relation(fields: [patientId], references: [id])
  chat            Chat
  
  @@unique([doctorId, patientId])
  @@index([doctorId])
  @@index([patientId])
  @@index([status])
  @@index([status,connectedAt])

  @@map("doctor_patient_connections")
}

model FollowUpRequest  {
  id        String @id @default(uuid())
  patientId String
  doctorId  String
  prescriptionImage   String        // صورة الروشتة (required)
  notes               String?
  status              RequestStatus @default(PENDING)
  rejectionReason     String?


      // Timestamps
  requestDate         DateTime      @default(now())
  responseDate        DateTime?
  respondedBy         String?       // Doctor ID

  // Relations
  patient Patient @relation(fields: [patientId], references: [id])
  doctor  Doctor  @relation(fields: [doctorId], references: [id])

  @@map("follow_up_requests")
}

model MedicalRecord {
  id        String @id @default(uuid())
  patientId String?
  doctorId      String?
  connectionId   String?          // المتعلق بأي connection
  
  // File Info
  fileName       String           // Original filename
  fileUrl        String           // Storage URL/path
  fileType       DocumentType         // X_RAY, LAB_RESULT, PRESCRIPTION, etc.
  fileSize       Int              // in bytes
  mimeType       String           // image/jpeg, application/pdf, etc.
  

  // Medical Info
  title       String
  description String?
  treatment   String?
  medications String?
  uploadedBy     String           // USER_ID (patient or doctor)
   // Status
  isVerified     Boolean          @default(false) // Doctor verified
  notes          String?          // Doctor's notes on the file

  

  // File attachments
  attachments Json?

  recordDate DateTime @default(now())
  createdAt  DateTime @default(now())
  updatedAt  DateTime @updatedAt

  // Relations
  patient Patient? @relation(fields: [patientId], references: [id])
  doctor  Doctor? @relation(fields: [doctorId],references: [id])
  connection     DoctorPatientConnection?      @relation(fields: [connectionId], references: [id], onDelete: SetNull)
  

  @@index([patientId])
  @@index([doctorId])
  @@index([connectionId])
  @@index([createdAt])
  @@index([recordDate])
}
model Prescription {
  id            String  @id @default(uuid())
  connectionId  String
  doctorId      String
  patientId     String
  medications   Json // Array of medications
  /*
  [
    {
      name: "Panadol",
      frequency: 3,
      frequencyType: "daily", // daily, weekly
      notes: "بعد الأكل",
      duration: "7 days"
    }
  ]
  */
  notes         String?
  isActive      Boolean @default(true)

  prescribedAt  DateTime
  updateAt      DateTime

  //relation

  connection    DoctorPatientConnection @relation(fields: [connectionId], references: [id])
  doctor        Doctor  @relation(fields: [doctorId], references: [id])
  patient       Patient @relation(fields: [patientId], references: [id])

  @@index([isActive])
  @@index([prescribedAt])
  
  @@map("prescriptions")
}

model QrToken {
  id           String    @id @default(uuid())
  doctorId     String
  token        String    @unique
  type         String    @default("CONNECTION") // CONNECTION, PRESCRIPTION_VIEW, EMERGENCY_ACCESS
  expiresAt    DateTime
  isUsed       Boolean   @default(false)
  usedBy       String?   // Patient ID who used it
  usedAt       DateTime?
  metadata     Json?     // Extra data: {clinicRoom, notes, etc}
  createdAt    DateTime  @default(now())
  
  // Relations
  doctor Doctor @relation(fields: [doctorId], references: [id], onDelete: Cascade)
  patient Patient? @relation(fields: [usedBy], references: [id], onDelete: SetNull)
  
  @@index([token])
  @@index([doctorId])
  @@index([expiresAt])
  @@index([isUsed])
  @@map("qr_tokens")
}
model Chat {
  id                    String  @id  @default(uuid())
  connectionId          String
  
  // chat filed from performance 
  lastMassageAt         DateTime?
  LastMassagePreview    String?  @db.VarChar(255) // preview of last 255 characters

  createdAt             DateTime @default(now())
  updatedAt             DateTime @updatedAt

 //Relations    
  connection         DoctorPatientConnection  @relation(fields: [connectionId], references: [id])
  massages           Massage[]

 @@index([connectionId])
 @@index([lastMassageAt])
 
@@map("chats")

}

model Massage {
  id            String  @default(uuid())
  chatId        String
  senderId      String
  
  content      String   @db.Text
  massageType  String   @default("TEXT")  // TEXT, SYSTEM, FILE (for future expansion)

  isRead    Boolean    @default(false)
  readAt    DateTime?

  isDeleted    Boolean    @default(false)
  deletedAt    DateTime?


  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

//Relations
  chat Chat   @relation(fields: [chatId], references: [id])
  sender User @relation(fields: [senderId],references: [id])

@@index([chatId])
@@index([senderId])
@@index([createdAt])
@@index([isRead])
@@index([chatId,createdAt])

@@map("massages")

}